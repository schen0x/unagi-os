# OS30DAYS

## TABLE OF CONTENT


## DAY1 A BOOTABLE IMAGE

### RESULT

- ![d01-os-hello_world](./img/d01-os-hello_world.png)

```sh
IMG=d01/helloos.img; qemu-system-x86_64 -drive file=$IMG,format=raw,if=floppy
```

- ![d01-voyager0-greeting](./img/d01-voyager0-greeting.png)

```sh
ASM=d01/voyager0.asm; IMG=$(mktemp) && nasm $ASM -o $IMG && qemu-system-x86_64 -drive file=$IMG,format=raw,if=floppy
```

### Edit raw img

```sh
# The first bootable image, 1440KB FDA, FAT12
dd if=/dev/zero of=os.img bs=1024 count=1440
sudo mkfs -t fat os.img
# Then modified the bytes. (with VIM XXD)
```

### NASM to img

```sh
nasm os.nas -o os.img
```

- asm with Data Byte

```asm
DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
; ...
RESB 1469432
```

### BOOT SECTOR OF FAT

- [Boot Sector of FAT](https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Boot_Sector)
- [Volume Boot Record](https://en.wikipedia.org/wiki/Volume_boot_record)
- [DOS 4.0 EBPB](https://en.wikipedia.org/wiki/BIOS_parameter_block)
- [Local Block Addressing (LBA)](https://en.wikipedia.org/wiki/Logical_block_addressing)

- We essentially wrote an Boot Sector of MBR?
- WHAT IS `0xeb, 0x4e, 0x90`? It is A JUMP INSTRUCTION. `JMP 0x4e; NOP;` When an address is dectected during boot, chain access will start, execution will be passed to this command. This instruction will then skip over the non-executable of the sector.
- WHAT IS `0x55, 0xaa`? It is a "boot sector signature" (see VBR). Also, 0x1fe+2 == 0x200 == 512 Byte, the end of the sector.

- the BIOS Parameter Block (BPB) used in the book is the DOS 4.0 EBPB for FAT12, FAT16, FAT16B and HPFS (51bytes).


### FAT12 EBPB, floppy disk (textbook)

- [voyager0_os.asm](./d01/voyager0.asm)


## QEMU

```sh
# to boot from a raw img
qemu-system-x86_64 -drive file=helloos.img,format=raw
# compile and boot
ASM=fat12_os.asm; IMG=$(mktemp) && nasm $ASM -o $IMG && qemu-system-x86_64 -drive file=$IMG,format=raw,if=floppy
```


## PATCH BINARY WITH VIM

```sh
nvim example.bin
:%!xxd # display as mail safe hex dump
:%!xxd -r # to revert a mail safe hex dump to binary
```


## U02 REALMODE SEGMENTED MEMORY MODEL

### Segment Memory Model

- 8086 real mode, 16 bits + Segment Registers = 1MB memory access

#### 8086 Segment Registers

- CS, Code Segment
- SS, Stack Segment
- DS, Data Segment
- ES, Extra Segment

#### Calculating Absolute Offset

- Take the segment register, multiply it by 16 and add the offset
- Example:
    - Assume: Code Segment = 0x7c0
    - Assume: Assembly Origin "org" is set to zero (when assembled, OFFSET all code by 0)
    - (0x7c0 * 16) = 0x7c00
    - 0x7c00 + 0 = 0x7c00
- Other Example:
    - Segment 0 offset 0x7cff
    - Segment 0x7c0 offset 0xff
    - Segment 0x7cf offset 0x0f
- Example that loadsb use the Data Segment Register
    - ![u02-loadsb_manual](./img/u02-loadsb_manual.png)

```asm
org 0
mov ax, 0x7c0
mov ds, ax
mov si, 0x1f
; load char from 0x7c0 * 16 + 0x1f = 0x7c1f
lodsb
```

#### ACCESS MULTIPLE SEGMENTS WITH SEGMENT REGISTERS

```asm
; set al to the byte at [es * 16 + 32]
mov byte al, [es:32]
```

- SS(Stack Segment) = 0x00
- SP(Stack Pointer) = 0x7c00
- When push 0xffff (in 16 bit system, so only 4 bytes are pushed):
    - decrement the SP by 2 => SP = 0x7bfe
    - set 0x7bfe-0x7bff to 0xffff


## U04 INTERRUPT VECTOR TABLE (IVT) (REAL MODE ONLY)

- Interrupt are subroutines

- Processor is interrupted
- Old state saved on the stack
- Interrupt executed

- The table describe 256 interrupt handlers
- Each entry contains 4 bytes (2 bytes OFFSET: 2 bytes SEGMENT)
- The interrupts are in numeric order in the table

- Interrupt 0x13 is at offset 0x13 * 4 bytes = 0x46

- Interrupt ends till an IRET instruction


### EXCEPTIONS

- [osdev Exceptions](https://wiki.osdev.org/Exceptions)
- The exceptions are interrupts generated by **CPUs** when an 'error' occures.

## U05 DISK ACCESS AND HOW IT WORKS

- Files do not exist. Filesystems are implemented by kernel
- Implementing a filesystems requires the kernel programmer to create a filesystem driver for the target filesystem
- Data is read and written in sectors (e.g. 512 bytes)


### CHS (CYLINDER HEAD SECTOR)

- Legacy
- "head", "track", "sector"

### LBA (LOGICAL BLOCK ADDRESS)

- morden way of reading a HDD
- specify a number (sector) that start from zero

- LBA 0 = first sector on the disk
- LBA 1 = second sector on the disk

- Math: 58376 bytes
    - LBA: int(58376 / 512) = 114
    - Offset: 58376 % 512 = 8
    - 144 * 512 + 8 = 58376

### BIOS DISK ROUTINES

- In 16 bit real mode the BIOS provided interrupt 13h for disk operations
- In 32 bit protected mode we need to write our own a disk driver.

### READ CUSTOM BLOCK

- Use BIOS interrupt call 13h to interact with harddisk sectors directly
- INT 13h AH=02h: DISK - READ SECTOR(S) INTO MEMORY

## U06 INTRODUCING PROTECTED MODE

- Different level of access
    - Ring 0
    - Ring 1
    - Ring 2
    - Ring 3
        - cannot use cli sti

- Different memory scheme (Paging)
    - SELECTOR MEMORY SCHEME (?)
    - PAGING MEMORY SCHEME (Most common)

- 4GB of Addressable Memory (if 32 bit), compare to the realmode's 1MB


## U07 GCC CROSS COMPILER

- Build a customized cross compiler that does not link to default Linux library.
- [osdev gcc cross compiler](https://wiki.osdev.org/GCC_Cross-Compiler)
- Download src of `binutils` and `gcc`
- Build and install `binutils` and GCC_CROSS_COMPILER.
    - To install for the user only: `$HOME/opt/cross`
    - To install globally: `/usr/local/cross`

## U08



### ENTERING PROTECTED MODE

- [protected mode, osdev wiki](https://wiki.osdev.org/Protected_Mode)



## ASSEMBLY

### SEGMENT OVERRIDE PREFIX AND DEFAULT SEGMENT

- `SS:` is a segment override prefix
- Search for "default segment" in the intel manual to see more specific rules (`Specifying a Segment Selector`), some common ones are as follows:
    - REFERENCE_TYPE      REGISTER_USED
    - Instructions        CS
    - Stack               SS
    - Local_Data          DS
    - Destination_Strings ES

