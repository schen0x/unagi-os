# OS30DAYS

## TABLE OF CONTENT


## Section 3: Real Mode Development

## DAY1 A BOOTABLE IMAGE

### RESULT

- ![d01-os-hello_world](./img/d01-os-hello_world.png)

```sh
IMG=d01/helloos.img; qemu-system-x86_64 -drive file=$IMG,format=raw,if=floppy
```

- ![d01-voyager0-greeting](./img/d01-voyager0-greeting.png)

```sh
ASM=d01/voyager0.asm; IMG=$(mktemp) && nasm $ASM -o $IMG && qemu-system-x86_64 -drive file=$IMG,format=raw,if=floppy
```

### Edit raw img

```sh
# The first bootable image, 1440KB FDA, FAT12
dd if=/dev/zero of=os.img bs=1024 count=1440
sudo mkfs -t fat os.img
# Then modified the bytes. (with VIM XXD)
```

### NASM to img

```sh
nasm os.nas -o os.img
```

- asm with Data Byte

```asm
DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
; ...
RESB 1469432
```

### BOOT SECTOR OF FAT

- [Boot Sector of FAT](https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Boot_Sector)
- [Volume Boot Record](https://en.wikipedia.org/wiki/Volume_boot_record)
- [DOS 4.0 EBPB](https://en.wikipedia.org/wiki/BIOS_parameter_block)
- [Local Block Addressing (LBA)](https://en.wikipedia.org/wiki/Logical_block_addressing)

- We essentially wrote an Boot Sector of MBR?
- WHAT IS `0xeb, 0x4e, 0x90`? It is A JUMP INSTRUCTION. `JMP 0x4e; NOP;` When an address is dectected during boot, chain access will start, execution will be passed to this command. This instruction will then skip over the non-executable of the sector.
- WHAT IS `0x55, 0xaa`? It is a "boot sector signature" (see VBR). Also, 0x1fe+2 == 0x200 == 512 Byte, the end of the sector.

- the BIOS Parameter Block (BPB) used in the book is the DOS 4.0 EBPB for FAT12, FAT16, FAT16B and HPFS (51bytes).


### FAT12 EBPB, floppy disk (textbook)

- [voyager0_os.asm](./d01/voyager0.asm)


## QEMU

```sh
# to boot from a raw img
qemu-system-x86_64 -drive file=helloos.img,format=raw
# compile and boot
ASM=fat12_os.asm; IMG=$(mktemp) && nasm $ASM -o $IMG && qemu-system-x86_64 -drive file=$IMG,format=raw,if=floppy
```


## PATCH BINARY WITH VIM

```sh
nvim example.bin
:%!xxd # display as mail safe hex dump
:%!xxd -r # to revert a mail safe hex dump to binary
```


## U02 REALMODE SEGMENTED MEMORY MODEL

### Segment Memory Model

- 8086 real mode, 16 bits + Segment Registers = 1MB memory access

#### 8086 Segment Registers

- CS, Code Segment
- SS, Stack Segment
- DS, Data Segment
- ES, Extra Segment

#### Calculating Absolute Offset

- Take the segment register, multiply it by 16 and add the offset
- Example:
    - Assume: Code Segment = 0x7c0
    - Assume: Assembly Origin "org" is set to zero (when assembled, OFFSET all code by 0)
    - (0x7c0 * 16) = 0x7c00
    - 0x7c00 + 0 = 0x7c00
- Other Example:
    - Segment 0 offset 0x7cff
    - Segment 0x7c0 offset 0xff
    - Segment 0x7cf offset 0x0f
- Example that loadsb use the Data Segment Register
    - ![u02-loadsb_manual](./img/u02-loadsb_manual.png)

```asm
org 0
mov ax, 0x7c0
mov ds, ax
mov si, 0x1f
; load char from 0x7c0 * 16 + 0x1f = 0x7c1f
lodsb
```

#### ACCESS MULTIPLE SEGMENTS WITH SEGMENT REGISTERS

```asm
; set al to the byte at [es * 16 + 32]
mov byte al, [es:32]
```

- SS(Stack Segment) = 0x00
- SP(Stack Pointer) = 0x7c00
- When push 0xffff (in 16 bit system, so only 4 bytes are pushed):
    - decrement the SP by 2 => SP = 0x7bfe
    - set 0x7bfe-0x7bff to 0xffff


## U04 INTERRUPT VECTOR TABLE (IVT) (REAL MODE ONLY)

- INTERRUPTs are subroutines, when invoked:
  - Processor is interrupted
  - Old state saved on the stack
  - Interrupt executed

- The IVT table starts at the absolute address 0 in the memory.
  - Each entry contains 4 bytes (byte 0-1 OFFSET: byte 2-3 SEGMENT)
  - The interrupts are in numeric order in the table
  - The table describe 256 interrupt handlers

- An interrupt subroutine ends till an IRET instruction

- To call an interrupt, `int 0x13`
  - Interrupt 0 = address 0x00
  - Interrupt 1 = address 0x04
  - Interrupt 2 = address 0x08
  - Interrupt 0x13 = address 76

### EXCEPTIONS

- [osdev Exceptions](https://wiki.osdev.org/Exceptions)
- The exceptions are interrupts generated by **CPUs** when an 'error' occures.

## U05 DISK ACCESS AND HOW IT WORKS

- Files do not exist. Filesystems are implemented by kernel
- Implementing a filesystems requires the kernel programmer to create a filesystem driver for the target filesystem
- Data is read and written in sectors (e.g. 512 bytes)


### CHS (CYLINDER HEAD SECTOR)

- Legacy
- "head", "track", "sector"

### LBA (LOGICAL BLOCK ADDRESS)

- morden way of reading a HDD
- specify a number (sector) that start from zero

- LBA 0 = first sector on the disk
- LBA 1 = second sector on the disk

- Math: 58376 bytes
    - LBA: int(58376 / 512) = 114
    - Offset: 58376 % 512 = 8
    - 144 * 512 + 8 = 58376

### BIOS DISK ROUTINES

- In 16 bit real mode the BIOS provided interrupt 13h for disk operations
- In 32 bit protected mode we need to write our own a disk driver.

### READ CUSTOM BLOCK

- Use BIOS interrupt call 13h to interact with harddisk sectors directly
- INT 13h AH=02h: DISK - READ SECTOR(S) INTO MEMORY

## U06 INTRODUCING PROTECTED MODE

- Different level of access
    - Ring 0
    - Ring 1
    - Ring 2
    - Ring 3
        - cannot use cli sti

- Different memory scheme (Paging)
    - SELECTOR MEMORY SCHEME (?)
    - PAGING MEMORY SCHEME (Most common)

- 4GB of Addressable Memory (if 32 bit), compare to the realmode's 1MB


## U07 GCC CROSS COMPILER

- Build a customized cross compiler that does not link to default Linux library.
- [osdev gcc cross compiler](https://wiki.osdev.org/GCC_Cross-Compiler)
- Download src of `binutils` and `gcc`
- Build and install `binutils` and GCC_CROSS_COMPILER.
    - To install for the user only: `$HOME/opt/cross`
    - To install globally: `/usr/local/cross`


## SECTION 4 PROTECTED MODE DEVELOPMENT

- Protected Mode is a mode that protect memory & hardware from being accessed.
- Protected Mode can be divided into rings with different permission level: Ring 0 (kernel), Ring 1 & 2 (maybe device drivers), Ring 3 (normal user program)
- Protected Mode also give access to 32-bit Instructions and 4 GB of Addressable Memory (in Real Mode only 1MB)
- There are different memory schemes, a common one is Paging Memory Scheme


### U09 ENTERING PROTECTED MODE

- [protected mode, osdev wiki](https://wiki.osdev.org/Protected_Mode)

#### THE FAR JMP AFTER MOV CR0

- The `jmp` runs in 32 bit protected mode.
- The `08h` is a [Segment Selector](https://wiki.osdev.org/Segment_selector), that points to the first entry of GDTR with all flag cleared
- Addressing with Segment is different in proceted mode. [Segmentation Protected Mode](https://wiki.osdev.org/Segmentation#Protected_Mode)
- I.e., `SEGMENT_SELECTOR:OFFSET`
- The next segment is `10h:Offset` or `0b10,000:Offset`

```asm
mov cr0, eax
jmp 08h:PModeMain
```

#### GLOBAL DESCRIPTOR TABLE

- Use default GDT parameter values
- CALCULATE THE SEGMENT_SELECTOR USE ASM
- Since each Segment Descriptor is 64 bits (8 bytes).
- The following code calculate the segment selector with no flag.

```asm
CODE_SEG equ GDT_CODE - GDT_START			; Segment Selector with no flag
DATA_SEG equ GDT_DATA - GDT_START			; Segment Selector with no flag

GDT_START:
GDT_NULL:						; GDT Entry 0
    dd 0						; 4 bytes
    dd 0

; OFFSET 0x0
GDT_CODE:						; CS should point to this
    dw 0xffff						; Segment Limit, first 0-15 bits, 0xffff is 256MB in 4kb page
    dw 0						; Base Address 15:00
    db 0						; Base Address 23:16
    db 10011010b					; Common Access Byte 0x9a for Kernel Mode Code Segment
    db 11001111b					; Flags and Limit; Simply allow all memory access
    db 0						; Base 31:24

GDT_DATA:						; DS, SS, ES, FS, GS
    dw 0xffff						; Segment Limit, first 0-15 bits, 0xffff is 256MB in 4kb page
    dw 0						; Base Address 15:00
    db 0						; Base Address 23:16
    db 0x92						; Access Byte for Kernel Mode Data Segment
    db 11001111b					; Flags and Limit
    db 0						; Base 31:24
```


#### ENABLING THE A20 LINE

- A20 line exists for compatibility reasons. Enable it to access more than 1MB memory.
- [fast_A20_gate, OSDEV](https://wiki.osdev.org/A20_Line#Fast_A20_Gate)
- Enable the A20 in 32 bit code section.


## U10 USING C

- We want to write kernel in C, because it is simpler.
- Bootloader -> Load Protected Mode (use GDT to load a binary into memory segment) -> use a mini disk driver (ata read/write in LBA mode, because in Protected Mode direct IO is not allowed) to read 51.2 kb of the disk which contains our kernel binary, into a memory segment -> The binary is 32 bits, written in asm and C, sections are (4k) aligned.
- To create the binary, use a cross-compiler (binutils + gcc) for `TARGET=i686-elf`. A single object file is generated using nasm (asm part, `-f elf -g`), and gcc (C part, `-ffreestanding -g` and many other flags).
- gcc + linker script (section alignment, entry point) is used again (probably can be combined) to generate the final binary.
- Bootloader will jump to run the asm part, which will then setup the DS (according to the GDT parameters) and the stack, enable the A20 Line, then calls the C function.


### BUILD A CROSS COMPILER

- Install build dependencies [GCC_Cross-Compiler_Depencies, OSDEV](https://wiki.osdev.org/GCC_Cross-Compiler#Installing_Dependencies)
- Get the source code of binutils and gcc [Get binutils and gcc source code](https://wiki.osdev.org/GCC_Cross-Compiler#Downloading_the%20Source_Code)
- Follow the instruction to build a toolset whose `TARGET=i686-elf` [build binutils and gcc](https://wiki.osdev.org/GCC_Cross-Compiler#The_Build)

### USING C

- Seperate the 32 code, use C to generate object file.
- Link the object file, generate binary. The binary load instructions into a specific address.
- Jump to the address in the bootloader. I.e., The address can be where GDT_CODE section points to.

### ALIGNMENT

- We attached 2 binaries into 2.
- `bootloader` : `jmp 0x0100000`, which is the start of the kernel.o.
- Since kernel.asm needs to be run first (than other C code), the asm section need to be in the first section of the second binary.
- Then the kernel.asm may damage the alignment of the C code later.

- A solution: add paddings `times 512-($-$$) db 0`
- Or put the assembly code in the latest section, later than `.text` (which contains C code), then use some magic to jmp to that section first.

- Also, align all "Sections" during link time to 4KB, although C compiler usually do so by default. The 4096 bytes is also a common system page size.


## U13 C HELLO WORLD

- Use the VGA Text-mode interface to clear the screen and print.
- The Video Memory is mapped to a specific address (e.g., 0xB8000) during the boot process (probably handled by BIOS).
- [(VGA) Text Mode, OSDEV](https://wiki.osdev.org/Printing_To_Screen)

## U14 INTERRUPT DESCRIPTOR TABLE (IDT) (PROTECTED MODE INTERRUPTS)

- Initialize an array of IDT, usually IDT[256].
- Describe the array in IDTR ((length-1=0x7ff)(2 bytes) + base address (4 bytes))
- Define a interrupt handler and write the IDT array to the IDTR.
- Use `lidt[idtr]` in asm to load the Interrupt Descriptor Tables.
- Use `Int 0` to invoke an "Interrupt Gate" interrupt.
- (TODO? If IRET is necessary, this is done by asm, the IRET seems to loads many more registers from the stack than RET).


## ASSEMBLY

### SEGMENT OVERRIDE PREFIX AND DEFAULT SEGMENT

- `SS:` is a segment override prefix
- Search for "default segment" in the intel manual to see more specific rules (`Specifying a Segment Selector`), some common ones are as follows:
    - REFERENCE_TYPE      REGISTER_USED
    - Instructions        CS
    - Stack               SS
    - Local_Data          DS
    - Destination_Strings ES

